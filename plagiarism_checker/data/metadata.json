[
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\ini.c",
    "ext": ".c",
    "lang": "transact-sql",
    "chunk_id": 0,
    "chunk": "#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS) #define _CRT_SECURE_NO_WARNINGS #endif #include <stdio.h> #include <ctype.h> #include <string.h> #include \"ini.h\" #if !INI_USE_STACK #if INI_CUSTOM_ALLOCATOR #include <stddef.h> void* ini_malloc(size_t size); void ini_free(void* ptr); void* ini_realloc(void* ptr, size_t size); #else #include <stdlib.h> #define ini_malloc malloc #define ini_free free #define ini_realloc realloc #endif #endif #define MAX_SECTION 50 #define MAX_NAME 50 typedef struct { const char* ptr; size_t num_left; } ini_parse_string_ctx; static char* ini_rstrip(char* s) { char* p = s + strlen(s); while (p > s && isspace((unsigned char)(*--p))) *p = '\\0'; return s; } static char* ini_lskip(const char* s) { while (*s && isspace((unsigned char)(*s))) s++; return (char*)s; } static char* ini_find_chars_or_comment(const char* s, const char* chars) { #if INI_ALLOW_INLINE_COMMENTS int was_space = 0; while (*s && (!chars || !strchr(chars, *s)) && !(was_space && strchr(INI_INLINE_COMMENT_PREFIXES, *s))) { was_space = isspace((unsigned char)(*s)); s++; } #else while (*s && (!chars || !strchr(chars, *s))) { s++; } #endif return (char*)s; } static char* ini_strncpy0(char* dest, const char* src, size_t size) { size_t i; for (i = 0; i < size - 1 && src[i]; i++) dest[i] = src[i]; dest[i] = '\\0'; return dest; } int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler, void* user) { #if INI_USE_STACK char line[INI_MAX_LINE]; size_t max_line = INI_MAX_LINE; #else char* line; size_t max_line = INI_INITIAL_ALLOC; #endif #if INI_ALLOW_REALLOC && !INI_USE_STACK char* new_line; #endif char section[MAX_SECTION] = \"\"; #if INI_ALLOW_MULTILINE char prev_name[MAX_NAME] = \"\"; #endif size_t offset; char* start; char* end; char* name; char* value; int lineno = 0; int error = 0; char abyss[16]; #if !INI_USE_STACK line = (char*)ini_malloc(INI_INITIAL_ALLOC); if (!line) { return"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\ini.c",
    "ext": ".c",
    "lang": "transact-sql",
    "chunk_id": 1,
    "chunk": "{ #if INI_USE_STACK char line[INI_MAX_LINE]; size_t max_line = INI_MAX_LINE; #else char* line; size_t max_line = INI_INITIAL_ALLOC; #endif #if INI_ALLOW_REALLOC && !INI_USE_STACK char* new_line; #endif char section[MAX_SECTION] = \"\"; #if INI_ALLOW_MULTILINE char prev_name[MAX_NAME] = \"\"; #endif size_t offset; char* start; char* end; char* name; char* value; int lineno = 0; int error = 0; char abyss[16]; #if !INI_USE_STACK line = (char*)ini_malloc(INI_INITIAL_ALLOC); if (!line) { return -2; } #endif #if INI_HANDLER_LINENO #define HANDLER(u, s, n, v) handler(u, s, n, v, lineno) #else #define HANDLER(u, s, n, v) handler(u, s, n, v) #endif while (reader(line, (int)max_line, stream) != NULL) { offset = strlen(line); #if INI_ALLOW_REALLOC && !INI_USE_STACK while (offset == max_line - 1 && line[offset - 1] != '\\n') { max_line *= 2; if (max_line > INI_MAX_LINE) max_line = INI_MAX_LINE; new_line = ini_realloc(line, max_line); if (!new_line) { ini_free(line); return -2; } line = new_line; if (reader(line + offset, (int)(max_line - offset), stream) == NULL) break; offset += strlen(line + offset); if (max_line >= INI_MAX_LINE) break; } #endif lineno++; if (offset == max_line - 1 && line[offset - 1] != '\\n') { while (reader(abyss, sizeof(abyss), stream) != NULL) { if (!error) error = lineno; if (abyss[strlen(abyss) - 1] == '\\n') break; } } start = line; #if INI_ALLOW_BOM if (lineno == 1 && (unsigned char)start[0] == 0xEF && (unsigned char)start[1] == 0xBB && (unsigned char)start[2] == 0xBF) { start += 3; } #endif start = ini_rstrip(ini_lskip(start)); if (strchr(INI_START_COMMENT_PREFIXES, *start)) { } #if INI_ALLOW_MULTILINE else if (*prev_name && *start && start > line) { #if INI_ALLOW_INLINE_COMMENTS end = ini_find_chars_or_comment(start, NULL); if"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\ini.c",
    "ext": ".c",
    "lang": "transact-sql",
    "chunk_id": 2,
    "chunk": "- 1] == '\\n') break; } } start = line; #if INI_ALLOW_BOM if (lineno == 1 && (unsigned char)start[0] == 0xEF && (unsigned char)start[1] == 0xBB && (unsigned char)start[2] == 0xBF) { start += 3; } #endif start = ini_rstrip(ini_lskip(start)); if (strchr(INI_START_COMMENT_PREFIXES, *start)) { } #if INI_ALLOW_MULTILINE else if (*prev_name && *start && start > line) { #if INI_ALLOW_INLINE_COMMENTS end = ini_find_chars_or_comment(start, NULL); if (*end) *end = '\\0'; ini_rstrip(start); #endif if (!HANDLER(user, section, prev_name, start) && !error) error = lineno; } #endif else if (*start == '[') { end = ini_find_chars_or_comment(start + 1, \"]\"); if (*end == ']') { *end = '\\0'; ini_strncpy0(section, start + 1, sizeof(section)); #if INI_ALLOW_MULTILINE *prev_name = '\\0'; #endif #if INI_CALL_HANDLER_ON_NEW_SECTION if (!HANDLER(user, section, NULL, NULL) && !error) error = lineno; #endif } else if (!error) {"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\ini.c",
    "ext": ".c",
    "lang": "transact-sql",
    "chunk_id": 3,
    "chunk": "                \n                error = lineno;\n            }\n        }\n        else if (*start) {\n            \n            end = ini_find_chars_or_comment(start, \"=:\");\n            if (*end == '=' || *end == ':') {\n                *end = '\\0';\n                name = ini_rstrip(start);\n                value = end + 1;\n#if INI_ALLOW_INLINE_COMMENTS\n                end = ini_find_chars_or_comment(value, NULL);\n                if (*end)\n                    *end = '\\0';\n#endif\n                value = ini_lskip(value);\n                ini_rstrip(value);\n\n#if INI_ALLOW_MULTILINE\n                ini_strncpy0(prev_name, name, sizeof(prev_name));\n#endif\n                \n                if (!HANDLER(user, section, name, value) && !error)\n                    error = lineno;\n            }\n            else if (!error) {\n                \n#if INI_ALLOW_NO_VALUE\n                *end = '\\0';\n                name = ini_rstrip(start);\n                if (!HANDLER(user, section, name, NULL) && !error)\n                    error = lineno;\n#else\n                error = lineno;\n#endif\n            }\n        }\n\n#if INI_STOP_ON_FIRST_ERROR\n        if (error)\n            break;\n#endif\n    }\n\n#if !INI_USE_STACK\n    ini_free(line);\n#endif\n\n    return error;\n}\n\n\nint ini_parse_file(FILE* file, ini_handler handler, void* user)\n{\n    return ini_parse_stream((ini_reader)fgets, file, handler, user);\n}\n\n\nint ini_parse(const char* filename, ini_handler handler, void* user)\n{\n    FILE* file;\n    int error;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        return -1;\n    error = ini_parse_file(file, handler, user);\n    fclose(file);\n    return error;\n}\n\n\nstatic char* ini_reader_string(char* str, int num, void* stream) {\n    ini_parse_string_ctx* ctx = (ini_parse_string_ctx*)stream;\n    const char* ctx_ptr = ctx->ptr;\n    size_t ctx_num_left = ctx->num_left;\n    char* strp = str;\n    char c;\n\n    if (ctx_num_left == 0 || num < 2)\n        return NULL;\n\n    while (num > 1 && ctx_num_left != 0) {\n        c = *ctx_ptr++;\n        ctx_num_left--;\n        *strp++ = c;\n        if (c == '\\n')\n            break;\n        num--;\n    }\n\n    *strp = '\\0';\n    ctx->ptr = ctx_ptr;\n    ctx->num_left = ctx_num_left;\n    return str;\n}\n\n\nint ini_parse_string(const char* string, ini_handler handler, void* user) {\n    ini_parse_string_ctx ctx;\n\n    ctx.ptr = string;\n    ctx.num_left = strlen(string);\n    return ini_parse_stream((ini_reader)ini_reader_string, &ctx, handler,\n                            user);\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\cpp\\INIReader.cpp",
    "ext": ".cpp",
    "lang": "transact-sql",
    "chunk_id": 0,
    "chunk": "\n\n\n\n#include <algorithm>\n#include <cctype>\n#include <cstdlib>\n#include \"../ini.h\"\n#include \"INIReader.h\"\n\nusing std::string;\n\nINIReader::INIReader(const string& filename)\n{\n    _error = ini_parse(filename.c_str(), ValueHandler, this);\n}\n\nINIReader::INIReader(const char *buffer, size_t buffer_size)\n{\n  string content(buffer, buffer_size);\n  _error = ini_parse_string(content.c_str(), ValueHandler, this);\n}\n\nint INIReader::ParseError() const\n{\n    return _error;\n}\n\nstring INIReader::Get(const string& section, const string& name, const string& default_value) const\n{\n    string key = MakeKey(section, name);\n    return _values.count(key) ? _values.find(key)->second : default_value;\n}\n\nstring INIReader::GetString(const string& section, const string& name, const string& default_value) const\n{\n    const string str = Get(section, name, \"\");\n    return str.empty() ? default_value : str;\n}\n\nlong INIReader::GetInteger(const string& section, const string& name, long default_value) const\n{\n    string valstr = Get(section, name, \"\");\n    const char* value = valstr.c_str();\n    char* end;\n    long n = strtol(value, &end, 0);\n    return end > value ? n : default_value;\n}\n\nINI_API int64_t INIReader::GetInteger64(const string& section, const string& name, int64_t default_value) const\n{\n    string valstr = Get(section, name, \"\");\n    const char* value = valstr.c_str();\n    char* end;\n    int64_t n = strtoll(value, &end, 0);\n    return end > value ? n : default_value;\n}\n\nunsigned long INIReader::GetUnsigned(const string& section, const string& name, unsigned long default_value) const\n{\n    string valstr = Get(section, name, \"\");\n    const char* value = valstr.c_str();\n    char* end;\n    unsigned long n = strtoul(value, &end, 0);\n    return end > value ? n : default_value;\n}\n\nINI_API uint64_t INIReader::GetUnsigned64(const string& section, const string& name, uint64_t default_value) const\n{\n    string valstr = Get(section, name, \"\");\n    const char* value = valstr.c_str();\n    char* end;\n    uint64_t n = strtoull(value, &end, 0);\n    return end > value ? n : default_value;\n}\n\ndouble INIReader::GetReal(const string& section, const string& name, double default_value) const\n{\n    string valstr = Get(section, name, \"\");\n    const char* value = valstr.c_str();\n    char* end;\n    double n = strtod(value, &end);\n    return end > value ? n : default_value;\n}\n\nbool INIReader::GetBoolean(const string& section, const string& name, bool default_value) const\n{\n    string valstr = Get(section, name, \"\");\n    std::transform(valstr.begin(), valstr.end(), valstr.begin(),\n        [](const unsigned char& ch) { return static_cast<unsigned char>(::tolower(ch)); });\n    if (valstr == \"true\" || valstr == \"yes\" || valstr == \"on\" || valstr == \"1\")\n        return true;\n    else if (valstr == \"false\" || valstr == \"no\" || valstr == \"off\" || valstr == \"0\")\n        return false;\n    else\n        return default_value;\n}\n\nstd::vector<string> INIReader::Sections() const\n{\n    std::set<string> sectionSet;\n    for (std::map<string, string>::const_iterator it = _values.begin(); it != _values.end(); ++it) {\n        size_t pos = it->first.find('=');\n        if (pos != string::npos) {\n            sectionSet.insert(it->first.substr(0, pos));\n        }\n    }\n    return std::vector<string>(sectionSet.begin(), sectionSet.end());\n}\n\nstd::vector<string> INIReader::Keys(const string& section) const\n{\n    std::vector<string> keys;\n    string keyPrefix = MakeKey(section, \"\");\n    for (std::map<string, string>::const_iterator it = _values.begin(); it != _values.end(); ++it) {\n        if (it->first.compare(0, keyPrefix.length(), keyPrefix) == 0) {\n            keys.push_back(it->first.substr(keyPrefix.length()));\n        }\n    }\n    return keys;\n}\n\nbool INIReader::HasSection(const string& section) const\n{\n    const string key = MakeKey(section, \"\");\n    std::map<string, string>::const_iterator pos = _values.lower_bound(key);\n    if (pos == _values.end())\n        return false;\n    return pos->first.compare(0, key.length(), key) == 0;\n}\n\nbool INIReader::HasValue(const string& section, const string& name) const\n{\n    string key = MakeKey(section, name);\n    return _values.count(key);\n}\n\nstring INIReader::MakeKey(const string& section, const string& name)\n{\n    string key = section + \"=\" + name;\n    std::transform(key.begin(), key.end(), key.begin(),\n        [](const unsigned char& ch) { return static_cast<unsigned char>(::tolower(ch)); });\n    return key;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\cpp\\INIReader.cpp",
    "ext": ".cpp",
    "lang": "transact-sql",
    "chunk_id": 1,
    "chunk": "\nint INIReader::ValueHandler(void* user, const char* section, const char* name,\n                            const char* value)\n{\n    if (!name)  // Happens when INI_CALL_HANDLER_ON_NEW_SECTION enabled\n        return 1;\n    INIReader* reader = static_cast<INIReader*>(user);\n    string key = MakeKey(section, name);\n    if (reader->_values[key].size() > 0)\n        reader->_values[key] += \"\\n\";\n    reader->_values[key] += value ? value : \"\";\n    return 1;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\examples\\INIReaderExample.cpp",
    "ext": ".cpp",
    "lang": "gdscript",
    "chunk_id": 0,
    "chunk": "\n#include <iostream>\n#include \"../cpp/INIReader.h\"\n\nint main()\n{\n    INIReader reader(\"../examples/test.ini\");\n\n    if (reader.ParseError() < 0) {\n        std::cout << \"Can't load 'test.ini'\\n\";\n        return 1;\n    }\n    std::cout << \"Config loaded from 'test.ini': version=\"\n              << reader.GetInteger(\"protocol\", \"version\", -1) << \", unsigned version=\"\n              << reader.GetUnsigned(\"protocol\", \"version\", -1) << \", trillion=\"\n              << reader.GetInteger64(\"user\", \"trillion\", -1) << \", unsigned trillion=\"\n              << reader.GetUnsigned64(\"user\", \"trillion\", -1) << \", name=\"\n              << reader.Get(\"user\", \"name\", \"UNKNOWN\") << \", email=\"\n              << reader.Get(\"user\", \"email\", \"UNKNOWN\") << \", pi=\"\n              << reader.GetReal(\"user\", \"pi\", -1) << \", active=\"\n              << reader.GetBoolean(\"user\", \"active\", true) << \"\\n\";\n    std::cout << \"Has values: user.name=\" << reader.HasValue(\"user\", \"name\")\n              << \", user.nose=\" << reader.HasValue(\"user\", \"nose\") << \"\\n\";\n    std::cout << \"Has sections: user=\" << reader.HasSection(\"user\")\n              << \", fizz=\" << reader.HasSection(\"fizz\") << \"\\n\";\n    \n    std::cout << \"Sections:\\n\";\n    std::vector<std::string> sections = reader.Sections();\n    for (std::vector<std::string>::const_iterator it = sections.begin(); it != sections.end(); ++it) {\n        std::cout << \"- \" << *it << \"\\n\";\n    }\n    \n    for (std::vector<std::string>::const_iterator it = sections.begin(); it != sections.end(); ++it) {\n        std::cout << \"Keys in section [\" << *it << \"]:\\n\";\n        std::vector<std::string> keys = reader.Keys(*it);\n        for (std::vector<std::string>::const_iterator kit = keys.begin(); kit != keys.end(); ++kit) {\n            std::cout << \"- \" << *kit << \"\\n\";\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\examples\\ini_dump.c",
    "ext": ".c",
    "lang": "gdscript",
    "chunk_id": 0,
    "chunk": "\n\n#include <stdio.h>\n#include <string.h>\n#include \"../ini.h\"\n\nstatic int dumper(void* user, const char* section, const char* name,\n                  const char* value)\n{\n    static char prev_section[50] = \"\";\n\n    if (strcmp(section, prev_section)) {\n        printf(\"%s[%s]\\n\", (prev_section[0] ? \"\\n\" : \"\"), section);\n        strncpy(prev_section, section, sizeof(prev_section));\n        prev_section[sizeof(prev_section) - 1] = '\\0';\n    }\n    printf(\"%s = %s\\n\", name, value);\n    return 1;\n}\n\nint main(int argc, char* argv[])\n{\n    int error;\n\n    if (argc <= 1) {\n        printf(\"Usage: ini_dump filename.ini\\n\");\n        return 1;\n    }\n\n    error = ini_parse(argv[1], dumper, NULL);\n    if (error < 0) {\n        printf(\"Can't read '%s'!\\n\", argv[1]);\n        return 2;\n    }\n    else if (error) {\n        printf(\"Bad config file (first error on line %d)!\\n\", error);\n        return 3;\n    }\n    return 0;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\examples\\ini_example.c",
    "ext": ".c",
    "lang": "gdscript",
    "chunk_id": 0,
    "chunk": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"../ini.h\"\n\ntypedef struct\n{\n    int version;\n    const char* name;\n    const char* email;\n} configuration;\n\nstatic int handler(void* user, const char* section, const char* name,\n                   const char* value)\n{\n    configuration* pconfig = (configuration*)user;\n\n    #define MATCH(s, n) strcmp(section, s) == 0 && strcmp(name, n) == 0\n    if (MATCH(\"protocol\", \"version\")) {\n        pconfig->version = atoi(value);\n    } else if (MATCH(\"user\", \"name\")) {\n        pconfig->name = strdup(value);\n    } else if (MATCH(\"user\", \"email\")) {\n        pconfig->email = strdup(value);\n    } else {\n        return 0;  \n    }\n    return 1;\n}\n\nint main(int argc, char* argv[])\n{\n    configuration config;\n    config.version = 0;  \n    config.name = NULL;\n    config.email = NULL;\n\n    if (ini_parse(\"test.ini\", handler, &config) < 0) {\n        printf(\"Can't load 'test.ini'\\n\");\n        return 1;\n    }\n    printf(\"Config loaded from 'test.ini': version=%d, name=%s, email=%s\\n\",\n        config.version, config.name, config.email);\n\n    if (config.name)\n        free((void*)config.name);\n    if (config.email)\n        free((void*)config.email);\n\n    return 0;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\examples\\ini_xmacros.c",
    "ext": ".c",
    "lang": "gdscript",
    "chunk_id": 0,
    "chunk": "\n\n#include <stdio.h>\n#include <string.h>\n#include \"../ini.h\"\n\n\ntypedef struct {\n    #define CFG(s, n, default) char *s##_##n;\n    #include \"config.def\"\n} config;\n\n\nconfig Config = {\n    #define CFG(s, n, default) default,\n    #include \"config.def\"\n};\n\n\nint handler(void *user, const char *section, const char *name,\n            const char *value)\n{\n    config *cfg = (config *)user;\n\n    if (0) ;\n    #define CFG(s, n, default) else if (strcmp(section, #s)==0 && \\\n        strcmp(name, #n)==0) cfg->s##_##n = strdup(value);\n    #include \"config.def\"\n\n    return 1;\n}\n\n\nvoid dump_config(config *cfg)\n{\n    #define CFG(s, n, default) printf(\"%s_%s = %s\\n\", #s, #n, cfg->s##_##n);\n    #include \"config.def\"\n}\n\nint main(int argc, char* argv[])\n{\n    if (ini_parse(\"test.ini\", handler, &Config) < 0)\n        printf(\"Can't load 'test.ini', using defaults\\n\");\n    dump_config(&Config);\n    return 0;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\inih\\fuzzing\\inihfuzz.c",
    "ext": ".c",
    "lang": "gdscript",
    "chunk_id": 0,
    "chunk": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"../ini.h\"\n\nint User;\nchar Prev_section[50];\n\nint dumper(void* user, const char* section, const char* name,\n           const char* value)\n{\n    User = *((int*)user);\n    if (!name || strcmp(section, Prev_section)) {\n        printf(\"... [%s]\\n\", section);\n        strncpy(Prev_section, section, sizeof(Prev_section));\n        Prev_section[sizeof(Prev_section) - 1] = '\\0';\n    }\n    if (!name) {\n        return 1;\n    }\n\n    printf(\"... %s%s%s;\\n\", name, value ? \"=\" : \"\", value ? value : \"\");\n\n    if (!value) {\n        return 1;\n    }\n\n    return strcmp(name, \"user\")==0 && strcmp(value, \"parse_error\")==0 ? 0 : 1;\n}\n\nvoid parse(const char* fname) {\n    static int u = 100;\n    int e;\n\n    *Prev_section = '\\0';\n    e = ini_parse(fname, dumper, &u);\n    printf(\"%s: e=%d user=%d\\n\", fname, e, User);\n    u++;\n}\n\nint main(int argc, char **argv)\n{\n    if (argc < 2) {\n        printf(\"usage: inihfuzz file.ini\\n\");\n        return 1;\n    }\n    parse(argv[1]);\n    return 0;\n}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\cmake_example\\setup.py",
    "ext": ".py",
    "lang": "python",
    "chunk_id": 0,
    "chunk": "import os\nimport re\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\n\nPLAT_TO_CMAKE = {\n    \"win32\": \"Win32\",\n    \"win-amd64\": \"x64\",\n    \"win-arm32\": \"ARM\",\n    \"win-arm64\": \"ARM64\",\n}\n\n\nclass CMakeExtension(Extension):\n    def __init__(self, name: str, sourcedir: str = \"\") -> None:\n        super().__init__(name, sources=[])\n        self.sourcedir = os.fspath(Path(sourcedir).resolve())\n\n\nclass CMakeBuild(build_ext):\n    def build_extension(self, ext: CMakeExtension) -> None:\n        ext_fullpath = Path.cwd() / self.get_ext_fullpath(ext.name)\n        extdir = ext_fullpath.parent.resolve()\n\n\n        debug = int(os.environ.get(\"DEBUG\", 0)) if self.debug is None else self.debug\n        cfg = \"Debug\" if debug else \"Release\"\n\n        cmake_generator = os.environ.get(\"CMAKE_GENERATOR\", \"\")\n\n        cmake_args = [\n            f\"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY={extdir}{os.sep}\",\n            f\"-DPYTHON_EXECUTABLE={sys.executable}\",\n            f\"-DCMAKE_BUILD_TYPE={cfg}\",  # not used on MSVC, but no harm\n        ]\n        build_args = []\n        if \"CMAKE_ARGS\" in os.environ:\n            cmake_args += [item for item in os.environ[\"CMAKE_ARGS\"].split(\" \") if item]\n\n        cmake_args += [f\"-DEXAMPLE_VERSION_INFO={self.distribution.get_version()}\"]\n\n        if self.compiler.compiler_type != \"msvc\":\n            if not cmake_generator or cmake_generator == \"Ninja\":\n                try:\n                    import ninja\n\n                    ninja_executable_path = Path(ninja.BIN_DIR) / \"ninja\"\n                    cmake_args += [\n                        \"-GNinja\",\n                        f\"-DCMAKE_MAKE_PROGRAM:FILEPATH={ninja_executable_path}\",\n                    ]\n                except ImportError:\n                    pass\n\n        else:\n            single_config = any(x in cmake_generator for x in {\"NMake\", \"Ninja\"})\n\n            contains_arch = any(x in cmake_generator for x in {\"ARM\", \"Win64\"})\n\n            if not single_config and not contains_arch:\n                cmake_args += [\"-A\", PLAT_TO_CMAKE[self.plat_name]]\n\n            if not single_config:\n                cmake_args += [\n                    f\"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{cfg.upper()}={extdir}\"\n                ]\n                build_args += [\"--config\", cfg]\n\n        if sys.platform.startswith(\"darwin\"):\n            archs = re.findall(r\"-arch (\\S+)\", os.environ.get(\"ARCHFLAGS\", \"\"))\n            if archs:\n                cmake_args += [\"-DCMAKE_OSX_ARCHITECTURES={}\".format(\";\".join(archs))]\n\n        if \"CMAKE_BUILD_PARALLEL_LEVEL\" not in os.environ:\n            if hasattr(self, \"parallel\") and self.parallel:\n                build_args += [f\"-j{self.parallel}\"]\n\n        build_temp = Path(self.build_temp) / ext.name\n        if not build_temp.exists():\n            build_temp.mkdir(parents=True)\n\n        subprocess.run(\n            [\"cmake\", ext.sourcedir, *cmake_args], cwd=build_temp, check=True\n        )\n        subprocess.run(\n            [\"cmake\", \"--build\", \".\", *build_args], cwd=build_temp, check=True\n        )\n\n\nsetup(\n    name=\"cmake_example\",\n    version=\"0.0.1\",\n    author=\"Dean Moldovan\",\n    author_email=\"dean0x7d@gmail.com\",\n    description=\"A test project using pybind11 and CMake\",\n    long_description=\"\",\n    ext_modules=[CMakeExtension(\"cmake_example\")],\n    cmdclass={\"build_ext\": CMakeBuild},\n    zip_safe=False,\n    extras_require={\"test\": [\"pytest>=6.0\"]},\n    python_requires=\">=3.7\",\n)"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\cmake_example\\docs\\conf.py",
    "ext": ".py",
    "lang": "transact-sql",
    "chunk_id": 0,
    "chunk": "\n\n\n\n\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.autosummary',\n    'sphinx.ext.napoleon',\n]\n\nautosummary_generate = True\n\ntemplates_path = ['_templates']\n\nsource_suffix = '.rst'\n\n\nmaster_doc = 'index'\n\nproject = 'cmake_example'\ncopyright = '2016, Sylvain Corlay'\nauthor = 'Sylvain Corlay'\n\nversion = '0.0.1'\nrelease = '0.0.1'\n\nlanguage = None\n\n\nexclude_patterns = ['_build']\n\n\n\n\n\npygments_style = 'sphinx'\n\n\n\ntodo_include_todos = False\n\n\n\nhtml_theme = 'alabaster'\n\n\n\n\n\n\n\nhtml_static_path = ['_static']\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtmlhelp_basename = 'cmake_exampledoc'\n\n\nlatex_elements = {\n\n\n\n}\n\nlatex_documents = [\n    (master_doc, 'cmake_example.tex', 'cmake_example Documentation',\n     'Sylvain Corlay', 'manual'),\n]\n\n\n\n\n\n\n\n\n\nman_pages = [\n    (master_doc, 'cmake_example', 'cmake_example Documentation',\n     [author], 1)\n]\n\n\n\n\ntexinfo_documents = [\n    (master_doc, 'cmake_example', 'cmake_example Documentation',\n     author, 'cmake_example', 'One line description of project.',\n     'Miscellaneous'),\n]\n\n\n\n\n\n\nintersphinx_mapping = {'https://docs.python.org/': None}"
  },
  {
    "file": "C:\\Users\\User\\Desktop\\GITA_Final\\plagiarism_checker\\data\\repos\\cmake_example\\src\\main.cpp",
    "ext": ".cpp",
    "lang": "c",
    "chunk_id": 0,
    "chunk": "#include <pybind11/pybind11.h>\n\n#define STRINGIFY(x) #x\n#define MACRO_STRINGIFY(x) STRINGIFY(x)\n\nint add(int i, int j) {\n    return i + j;\n}\n\nnamespace py = pybind11;\n\nPYBIND11_MODULE(cmake_example, m) {\n    m.doc() = R\"pbdoc(\n        Pybind11 example plugin\n        -----------------------\n\n        .. currentmodule:: cmake_example\n\n        .. autosummary::\n           :toctree: _generate\n\n           add\n           subtract\n    )pbdoc\";\n\n    m.def(\"add\", &add, R\"pbdoc(\n        Add two numbers\n\n        Some other explanation about the add function.\n    )pbdoc\");\n\n    m.def(\"subtract\", [](int i, int j) { return i - j; }, R\"pbdoc(\n        Subtract two numbers\n\n        Some other explanation about the subtract function.\n    )pbdoc\");\n\n#ifdef VERSION_INFO\n    m.attr(\"__version__\") = MACRO_STRINGIFY(VERSION_INFO);\n#else\n    m.attr(\"__version__\") = \"dev\";\n#endif\n}"
  }
]